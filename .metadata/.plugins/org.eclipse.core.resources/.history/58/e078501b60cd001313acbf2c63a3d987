/*
 * AD_Offset.c
 *
 *  Created on: 2012. 8. 13.
 *      Author: HJHeo
 */

#define ADC7864					TARGET

#include "Define_Header.h"
#include "Define_ADC.h"

#define OFFSET_COUNT			10000
#define INV_OFFSET_COUNT		1.e-4L

int ADC_CH1_CONV = 0, ADC_CH2_CONV = 0, ADC_CH3_CONV = 0, ADC_CH4_CONV = 0;
int ADC_CH5_CONV = 0, ADC_CH6_CONV = 0, ADC_CH7_CONV = 0, ADC_CH8_CONV = 0;
float ADC_CH1_DATA = 0, ADC_CH2_DATA = 0, ADC_CH3_DATA = 0, ADC_CH4_DATA = 0;
float ADC_CH5_DATA = 0, ADC_CH6_DATA = 0, ADC_CH7_DATA = 0, ADC_CH8_DATA = 0;
float ADC_CH1_SUM = 0, ADC_CH2_SUM = 0, ADC_CH3_SUM = 0, ADC_CH4_SUM = 0;
float ADC_CH5_SUM = 0, ADC_CH6_SUM = 0, ADC_CH7_SUM = 0, ADC_CH8_SUM = 0;
float ADC_CH1_OFFSET = 0, ADC_CH2_OFFSET = 0, ADC_CH3_OFFSET = 0, ADC_CH4_OFFSET = 0;
float ADC_CH5_OFFSET = 0, ADC_CH6_OFFSET = 0, ADC_CH7_OFFSET = 0, ADC_CH8_OFFSET = 0;


void Init_ADC(void)
{
	ADC1_CS_ON;
	DELAY_US(1);
	*ADC_WR_ADDR = 0x3;
	ADC1_CS_OFF;

	ADC2_CS_ON;
	DELAY_US(1);
	*ADC_WR_ADDR = 0xF;
	ADC2_CS_OFF;

	return;
}

void ADC(void)
{
	// Conversion Start/
	ADC1_CV_ON;
	ADC2_CV_ON;

	ADC1_CV_OFF;
	ADC2_CV_OFF;

	DELAY_US(2);

	return;
}

void ADC_Read(void)
{
	// ADC1 Data Read
	ADC1_CS_ON;							// ADC1 Chip Selection.

	DELAY_US(0.05);

	ADC_CH1_CONV = *ADC_RD_ADDR;		// ADC1 Data1 Read.
	ADC_CH2_CONV = *ADC_RD_ADDR;		// ADC1 Data2 Read.
	ADC_CH3_CONV = *ADC_RD_ADDR;		// ADC1 Data3 Read.
	ADC_CH4_CONV = *ADC_RD_ADDR;		// ADC1 Data4 Read.

	ADC1_CS_OFF;						// Selection Release of ADC1 Chip.

	// ADC2 Data Read
	ADC2_CS_ON;							// ADC2 Chip Selection.

	DELAY_US(0.05);

	ADC_CH5_CONV = *ADC_RD_ADDR;		// ADC2 Data1 Read.
	ADC_CH6_CONV = *ADC_RD_ADDR;		// ADC2 Data2 Read.
	ADC_CH7_CONV = *ADC_RD_ADDR;		// ADC2 Data3 Read.
	ADC_CH8_CONV = *ADC_RD_ADDR;		// ADC2 Data4 Read.

	ADC2_CS_OFF;						// Selection Release of ADC2 Chip.

	// Data Conversion (Uint16 to float)
	ADC_CH1_DATA = (float)(ADC_CH1_CONV << 4 >> 4) * ADC_RESOLUTION;
	ADC_CH2_DATA = (float)(ADC_CH2_CONV << 4 >> 4) * ADC_RESOLUTION;
	ADC_CH3_DATA = (float)(ADC_CH3_CONV << 4 >> 4) * ADC_RESOLUTION;
	ADC_CH4_DATA = (float)(ADC_CH4_CONV << 4 >> 4) * ADC_RESOLUTION;

	ADC_CH5_DATA = (float)(ADC_CH5_CONV << 4 >> 4) * ADC_RESOLUTION;
	ADC_CH6_DATA = (float)(ADC_CH6_CONV << 4 >> 4) * ADC_RESOLUTION;
	ADC_CH7_DATA = (float)(ADC_CH7_CONV << 4 >> 4) * ADC_RESOLUTION;
	ADC_CH8_DATA = (float)(ADC_CH8_CONV << 4 >> 4) * ADC_RESOLUTION;

	return;
}


interrupt void ADC_Offset(void)
{
	static int offset_cnt = 0;

	Reset_WatchCat();

	ADC();
	DELAY_US(8);
	ADC_Read();

	ADC_CH1_SUM += ADC_CH1_DATA;
	ADC_CH2_SUM += ADC_CH2_DATA;
	ADC_CH3_SUM += ADC_CH3_DATA;
	ADC_CH4_SUM += ADC_CH4_DATA;
	ADC_CH5_SUM += ADC_CH5_DATA;
	ADC_CH6_SUM += ADC_CH6_DATA;
	ADC_CH7_SUM += ADC_CH7_DATA;
	ADC_CH8_SUM += ADC_CH8_DATA;

	if (offset_cnt++ >= OFFSET_COUNT)
	{
		ADC_CH1_OFFSET = ADC_CH1_SUM * INV_OFFSET_COUNT;
		ADC_CH2_OFFSET = ADC_CH2_SUM * INV_OFFSET_COUNT;
		ADC_CH3_OFFSET = ADC_CH3_SUM * INV_OFFSET_COUNT;
		ADC_CH4_OFFSET = ADC_CH4_SUM * INV_OFFSET_COUNT;
		ADC_CH5_OFFSET = ADC_CH5_SUM * INV_OFFSET_COUNT;
		ADC_CH6_OFFSET = ADC_CH6_SUM * INV_OFFSET_COUNT;
		ADC_CH7_OFFSET = ADC_CH7_SUM * INV_OFFSET_COUNT;
		ADC_CH8_OFFSET = ADC_CH8_SUM * INV_OFFSET_COUNT;

		EALLOW;
		PieVectTable.EPWM1_INT = &Interrupt;
		EDIS;
	}

	EPwm1Regs.ETCLR.bit.INT = 1;			// ePWM1 Interrupt Clear
	PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;	// ePWM1 PIE Interrupt Clear
}
